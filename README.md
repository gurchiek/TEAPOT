# TEAPOT

TEAPOT is an acronym for Track Everything Available, Predict Other Things. This describes a general approach for sparse-signal tracking simulations. A simple example can be implemented from this code using OpenSim Moco. You will need to have already [setup](https://simtk-confluence.stanford.edu:8443/display/OpenSim/Scripting+with+Matlab) use of the OpenSim API within MATLAB.

## Step 1
Run s1_baselineTrackingSimulation. This generates a physically consistent 2D walking gait by tracking reference coordinate and ground reaction force data. A single step is simulated and constraints are imposed to force bilateral symmetry in every state and the lumbar actuator control signal. An OUTPUT_s1_* folder will be created in which simulation results are stored.

## Step 2
Run s2_predictiveSimulation. This is a predictive simulation of 2D walking gait. No reference data are tracked. Constraints are imposed to force bilateral symmetry as in the step 1 tracking simulation and to match the gait speed of the reference data. The only objective function term represents control effort: the sum of the squared control signals of all system actuators (including muscles). Once the simulation has finished, the function synchronizeWithBaseline is called to time-synchronize the predicitve simulation trajectory with the reference tracking simulation from step 1 (using the GRF signal). An OUTPUT_s2_* folder will be created in which simulation results are stored (all files ending with _unsynchronized* are not synchronized with the reference tracking simulation; else they are). A precomputed solution to this problem using setGuess('bounds') solved with a 2021 iMac Apple M1 is used to initialize this simulation to speed up the optimization (see comments at the beginning of s2_predictiveSimulation.m).

## Step 3 (the TEAPOT approach)
Run s3_trackOnlyRightShankIMU. This is a tracking simulation where only (simulated) signals from a right shank-worn gyroscope (angular velocity) and accelerometer (specific force) are tracked. The IMU signals are generated using the reference tracking simulation. The simulated signals are noise- and bias-free. A full stride was simulated instead of a single step as in the simulations of steps 1 and 2 because no bilateral symmetry constraints were enforced in this simulation. A symmetry constraint was placed on each state with itself which models periodicity of the stride (the initial state is exactly the same as the last). No constraint was used to match the gait speed of the reference simulation of step 1. A precomputed solution to this problem using setGuess('bounds') solved with a 2021 iMac Apple M1 is used to initialize this simulation to speed up the optimization (see comments at the beginning of s3_trackOnlyRightShankIMU).

## Step 4
Run s4_compareSimulations.
This compares the difference between simulations 2 and 3 with simulation 1. The results demonstrate the improved performance facilitated by tracking the signals from even a single IMU under ideal conditions (noise-/bias-free signals). Characterization of mechanical variables are generally better for the right leg (the side on which the sensor signals were tracked).

## Note on simulation 3 (the TEAPOT approach)
I have confirmed that the s3_trackOnlyRightShankIMU will solve on a 2016 MacBook i7 chip using setGuess('bounds'), but it takes a while (7348 iterations). Another option would be to reference the s2_predictiveSimulation solution in setGuessFile(). However, although that problem was initialized with setGuess('bounds'), a constraint was used to force speed-matching with the reference trajectory (s1 solution). This is because the primary goal of this demo is to demonstrate the local (concerning joints/muscles close to the right shank) and global (e.g., muscles/coordinates parameterizing/actuating joints further from the right shank) benefits of tracking just the right shank IMU signals over the predictive one; a proper comparison with a predictive simulation would be speed-matched. In practice, one would initialize this problem not with 'bounds', but with something 'close'. For example, one could have a look-up of trajectories for pre-computed stride times (something readily computed with wearables) from predictive simulations to initialize the TEAPOT simulation. Another approach for consecutive strides would be to use the previous stride. Thus, the time to solve the problem here should not be interpreted as an exact reflection of how this approach would work in practice. The main idea here is to demonstrate proof of concept.
